---
title: Build Your Own CSV Parser
summary: Implement a robust CSV parser that handles edge cases and different dialects. Learn about parsing techniques, state machines, and data validation.
skills:
- Parsing
- State Machines
- Data Validation
- File Processing
difficulty: Intermediate
category: Parsing
estimatedTime: 4-6 hours
tier: free
---

This challenge is inspired by the need to parse CSV (Comma-Separated Values) files, one of the most common data exchange formats. While CSV appears simple on the surface, handling all edge cases correctly requires careful implementation of parsing logic. By building your own CSV parser, you'll learn about state machines, parsing techniques, and the complexities hidden in seemingly simple data formats.

## Table of Contents

CSV parsing demonstrates several important parsing concepts:

- **State Machine Design**: Track parsing context as you process characters.
- **Edge Case Handling**: Deal with quoted fields, embedded delimiters, and escape sequences.
- **Data Validation**: Ensure data integrity and handle malformed input gracefully.
- **Performance**: Process large files efficiently without loading everything into memory.

Understanding CSV parsing is crucial for data processing applications and will help you appreciate the complexity behind data interchange formats.

## The Challenge

Your task is to implement a CSV parser that can handle various CSV dialects and edge cases. The parser should be able to read CSV files, validate their structure, and convert them into structured data formats like arrays of objects or 2D arrays.

## CSV Format Specification

Your parser should handle the standard CSV format as defined in RFC 4180, plus common variations:

1. **Basic Structure**:
   - Records (rows) separated by line breaks (CRLF, LF, or CR)
   - Fields (columns) separated by delimiters (comma by default)
   - Optional header row with field names

2. **Quoted Fields**:
   - Fields containing delimiters, quotes, or line breaks must be enclosed in double quotes
   - Embedded quotes are escaped by doubling them (`""`)
   - Leading/trailing whitespace is preserved inside quotes

3. **Edge Cases**:
   - Empty fields and empty records
   - Mixed quoted and unquoted fields
   - Different line ending styles
   - Unicode content and different encodings

## Supported Features

Your CSV parser should support:

1. **Flexible Configuration**:
   - Customizable field delimiter (comma, semicolon, tab, pipe, etc.)
   - Configurable quote character (double quote by default)
   - Option to trim whitespace from unquoted fields
   - Header row detection and field naming

2. **Multiple Output Formats**:
   - Array of arrays (raw data)
   - Array of objects (with field names from header)
   - Stream processing for large files
   - JSON conversion

3. **Validation and Error Handling**:
   - Syntax error detection with line and column numbers
   - Data type validation and conversion
   - Handling of malformed records

## Example Usage

Here's how your CSV parser should work:

```python
# Basic CSV parsing
csv_content = """
name,age,city
John,25,New York
Jane,30,"San Francisco"
"""

parser = CSVParser()
data = parser.parse(csv_content)
# Result: [{"name": "John", "age": "25", "city": "New York"}, ...]

# Custom delimiter and configuration
parser = CSVParser(delimiter=';', has_header=True, trim_whitespace=True)
data = parser.parse_file('data.csv')

# Streaming for large files
parser = CSVParser()
for record in parser.parse_stream('large_file.csv'):
    process_record(record)

# Type conversion
parser = CSVParser(types={'age': int, 'salary': float})
data = parser.parse(csv_content)
```

## Complex CSV Examples

Your parser should handle these challenging cases:

```csv
# Mixed quoted and unquoted fields
Name,Description,Price
Widget,"A useful tool, contains ""quotes""",19.99
Gadget,Simple tool,5.00

# Embedded line breaks in quoted fields
Product,Description,Notes
"Multi-line
Product","This product
spans multiple lines","Important:
Handle carefully"

# Empty fields and records
A,B,C
1,,3

,,
2,2,2

# Different delimiters
Name;Age;Country
John;25;USA
Marie;30;France

# Unicode content
名前,年齢,国
田中,25,日本
スミス,30,アメリカ
```

## Implementation Steps

1. **State Machine Design**:
   - Define states: START, FIELD, QUOTED_FIELD, QUOTE_IN_QUOTE
   - Implement state transitions based on input characters
   - Handle delimiter, quote, and line ending characters specially

2. **Character Processing**:
   - Read input character by character or in chunks
   - Build current field content while tracking state
   - Handle different line ending styles (CRLF, LF, CR)

3. **Field and Record Management**:
   - Collect completed fields into records
   - Handle empty fields and records appropriately
   - Process header row if present

4. **Error Handling**:
   - Track line and column numbers for error reporting
   - Detect unterminated quotes and other syntax errors
   - Provide helpful error messages with context

5. **Output Generation**:
   - Convert parsed data to requested output format
   - Apply type conversions if specified
   - Handle Unicode and different character encodings

## Advanced Parsing Logic

```python
def parse_csv_state_machine(content):
    state = 'START'
    current_field = ''
    current_record = []
    records = []
    
    for char in content:
        if state == 'START':
            if char == '"':
                state = 'QUOTED_FIELD'
            elif char == delimiter:
                current_record.append('')
            elif char in line_endings:
                if current_record:
                    records.append(current_record)
                current_record = []
            else:
                current_field = char
                state = 'FIELD'
                
        elif state == 'FIELD':
            if char == delimiter:
                current_record.append(current_field)
                current_field = ''
                state = 'START'
            elif char in line_endings:
                current_record.append(current_field)
                records.append(current_record)
                current_field = ''
                current_record = []
                state = 'START'
            else:
                current_field += char
                
        # ... handle other states
```

## Extra Credit

Extend your CSV parser with these additional features:

1. **Advanced Validation**:
   - Schema validation with field types and constraints
   - Data consistency checks (duplicate detection, referential integrity)
   - Custom validation rules and callbacks
   - Statistical analysis of parsed data

2. **Performance Optimizations**:
   - Memory-efficient streaming for very large files
   - Parallel processing for multiple files
   - Caching and memoization for repeated patterns
   - Optimized string handling and memory allocation

3. **Enhanced Dialect Support**:
   - Excel CSV format variations
   - Tab-separated values (TSV)
   - Fixed-width column detection
   - Auto-detection of delimiter and quote characters

4. **Data Transformation**:
   - Built-in data type inference and conversion
   - Date/time parsing with multiple formats
   - Numeric formatting and locale support
   - Regular expression-based field validation

5. **Integration Features**:
   - Direct database import capabilities
   - JSON and XML output formats
   - Integration with data analysis libraries
   - Export to different CSV dialects

6. **Error Recovery**:
   - Attempt to recover from malformed records
   - Skip invalid records with warning messages
   - Partial parsing of corrupted files
   - Suggest corrections for common formatting errors

This challenge will teach you about the complexity behind data parsing, the importance of handling edge cases, and how to design robust parsers that can handle real-world data variations.